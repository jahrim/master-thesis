{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qmy family and my partner, for their compassion and comfort during these challenging past months.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qmy friends, for their understanding and their patience, during a time when I have not been as present.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[ caption=The three higher-order primitives introduced by aggregate computing on top of field calculus., captionpos=b, label=listing:aggregate-computing-blocks ]resources/listings/aggregate-computing-blocks.txt\\E$"}
{"rule":"LC_AFTER_PERIOD","sentence":"^\\QAlternatively, it is possible to create a new transaction explicitly using the Transaction.run method (e.g., useful for sending simultaneous events, graph initialization or handling forward references).\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qnever: create a new Stream that will never emit events.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qmap: given a Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q in input, create a new Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q whose events are the events of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q transformed with a given mapping function.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qfilter: given a Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q in input, create a new Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q whose events are the events of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, discarding those which do not satisfy a given predicate.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qmerge: given two Streams \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, create a new Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q whose events are the events fired by either \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q or \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, combining their simultaneous events with a given merging function.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qsnapshot: given a Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and a Cell \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, create a new Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q whose events are the events of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q combined with the most recent value of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q using a given combine function.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qconstant: create a Cell \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q holding a given value forever.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qhold: given a Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, create a Cell \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q holding a given initial value, which is updated each time \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q fires a new event.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qsample: given a Cell \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, obtain its most recent value.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qlift: given two Cells \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, create a new Cell \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q whose value is obtained by combining the values of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q using a given operator.\\E$"}
{"rule":"PUNCTUATION_PARAGRAPH_END","sentence":"^\\QSome primitives can be derived as a combination of the others (e.g., constant and snapshot)., captionpos=b, label=listing:sodium-basic ]resources/listings/sodium-basic.txt\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[ language=Scala, caption=An abstract view on the Sodium primitives for constructing static acyclic computational graphs.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QSome primitives can be derived as a combination of the others (e.g., constant and snapshot)., captionpos=b, label=listing:sodium-basic ]resources/listings/sodium-basic.txt\\E$"}
{"rule":"TOO_LONG_PARAGRAPH","sentence":"^\\QNote that lifting is explicit in Sodium.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[ language=Scala, caption=An abstract view on the Sodium primitives for constructing dynamic computational graphs., captionpos=b, label=listing:sodium-switching ]resources/listings/sodium-switching.txt\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[ language=Scala, caption=An abstract view on the Sodium primitives for constructing cyclic computational graphs., captionpos=b, label=listing:sodium-looping ]resources/listings/sodium-looping.txt\\E$"}
{"rule":"A_INFINITIVE","sentence":"^\\QIn particular, the send primitive implements non-FRP to FRP interactions, allowing pushing an update to a CellSink and managing the propagation of change through a push-based evaluation model (i.e., the caller of send will update all the dependent nodes in the computational graph).\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[ language=Scala, caption=An abstract view on the Sodium operational primitives., captionpos=b, label=listing:sodium-operational ]resources/listings/sodium-operational.txt\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[ language=Scala, caption=The core constructs of field calculus, represented as a trait, abstracting over the actual organization within ScaFi., captionpos=b, label=listing:scafi-field-calculus ]resources/listings/scafi-field-calculus.txt\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[ language=Scala, caption=The core constructs of aggregate computing, represented as a mixin for field calculus, abstracting the actual organization within ScaFi., captionpos=b, label=listing:scafi-aggregate-computing ]resources/listings/scafi-aggregate-computing.txt\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qcompute: the device computes its current output by executing the aggregate specification against its current context.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qinteract: the device broadcasts some information extracted from its output (called an export) to neighboring devices and updates the local environment through its actuators.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[ language=Scala, caption=The core constructs of the FRASP language, represented as a trait, abstracting over the actual organization within FRASP., captionpos=b, label=listing:frasp-language ]resources/listings/frasp-language.txt\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qcore: provide the model and implementation of the FRASP specification, as illustrated previously in Listing \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qsimulation: provide a basic simulator for running aggregate specifications over a network of devices.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qtake: when applied to an input FiniteStream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, return an output FiniteStream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, obtained by halting \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q after a given number of events.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QinterruptBy: when applied to an input FiniteStream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, return an output FiniteStream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, obtained by halting \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q at the first event of a given interruptor stream.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QtakeBefore: when applied to an input FiniteStream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, return an output FiniteStream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, obtained by halting \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q at the first event fired after a given duration has elapsed since the creation of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QinterruptAfter: when applied to an input FiniteStream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, return an output FiniteStream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, obtained by halting \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q after a given duration has elapsed since the creation of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QtakeBeforeInactivityOf: when applied to an input FiniteStream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, return an output FiniteStream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, obtained by halting \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q at the first event fired after a given duration has elapsed since its latest event.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QinterruptAfterInactivityOf: when applied to an input FiniteStream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, return an output FiniteStream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, obtained by halting \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q after a given duration has elapsed since its latest event.\\E$"}
{"rule":"TOO_LONG_PARAGRAPH","sentence":"^\\QThe operator relies on a Timer, similarly to interruptAfter.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qregional: a property of a group of devices in an aggregate (e.g., branch (isRed)obstaclesomethingElse should evaluate to obstacle for all red devices in the network).\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qindividual: a property of a single device in an aggregate (e.g., the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q device should always be a source of potential).\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qregional: a property of a group of devices in an aggregate (e.g., branch (isRed)obstaclesomethingElse should evaluate to obstacle for all red devices in the network).\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qregional: a property of a group of devices in an aggregate (e.g., branch (isRed)obstaclesomethingElse should evaluate to obstacle for all red devices in the network).\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qisolated: independent of other unit tests (i.e., concerning a single software unit).\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qreproducible: always yielding the same results under the same initial conditions (i.e., determinism).\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qfinite: yielding a result in a limited amount of time, ideally short for supporting frequent repeatability.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qautomated: executed each time a relevant (preferably small) increment of software is completed.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qcontrollability: it should be possible to control a simulation, leading it to a stable state when its execution does not converge in a finite amount of time.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qfairness: in aggregate tests, it should always be possible for every device to compute an export in the future.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qefficiency: it should be optimized to minimize execution time, possibly leveraging parallelism.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qreproducibility: multiple simulations should yield similar results under similar initial configurations, implying the ability to execute a simulation under similar conditions multiple times (repeatability) or under different conditions (replicability).\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[ language=Scala, caption=An application of StepSimulator.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThe simulator is used to display the device exports on the standard output., captionpos=b, label=listing:step-simulator-example ]resources/listings/step-simulator-example.txt\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[ language=Scala, caption=An application of ConcurrentSimulator.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QAdditionally, the exports are generated continually by the provided ExecutionContext after the simulation is started (after line 23, there is no next method to call)., captionpos=b, label=listing:concurrent-simulator-example ]resources/listings/concurrent-simulator-example.txt\\E$"}
{"rule":"COMMA_COMPOUND_SENTENCE_2","sentence":"^\\QHowever, to ensure that the result of computeLimit is a stable state of the aggregate, the specification should be self-stabilizing and the simulation should be halted after the aggregate has stabilized.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QBelow follows an analysis of the suitable HaltPolicys and their effects, assuming the user has complete control over the environment: haltWhen( == \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q): calling \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q the known stable state of the aggregate, the simulation can be halted when the aggregate is in state \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[ language=Scala, caption=An application of ConvergenceSimulator.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QFor simplicity, the stable states only show the root of the devices exports., captionpos=b, label=listing:convergence-simulator-example ]resources/listings/convergence-simulator-example.txt\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qcollect: evolve an initial state init as the input Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q generates new events and return an output Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, whose events are a combination of the events fired by \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q with the current state at the moment of firing.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe acc function defines both the evolution of the state and the events of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q depending on the firings of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qfold: a simplification of the collect operator, in which the events of the output Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q are a snapshot of the current state taken at each firing of the input Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qngrams: when applied to an input Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, return an output Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, whose events are all the possible groups of consecutive events fired by \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q with cardinality \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QngramsOption: as ngrams, but information loss is prevented by producing incomplete groups in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q until \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q has generated at least \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q events.\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\QNone is used as a placeholder value.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qmonitor: when applied to an input Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, return a StreamMonitor wrapping \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qthrottle: a specialization of the throttleWith operator, in which the output Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q fires the events of the first input Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, while the second input Stream \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q acts only as a throttle for \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q[ language=Scala, caption= An application of ConvergenceTest.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QFinally, at lines 18-33, a concrete convergence test is formulated: the test involves a gradient originating from all the devices tagged as sources (i.e., only the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q device); the evolution of the aggregate is expected to be convergent towards the given limit; and the test is iterated 10 times, failing automatically if convergence is not proven within 60 seconds., captionpos=b, label=listing:convergence-test-example ]resources/listings/convergence-test-example.txt\\E$"}
